Leetcode 题解 - 双指针
1. 有序数组的 Two Sum
参考SumTest.java方法
考点是双指针，一个指针指向较小的元素，一个指针指向较大的元素
时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为 O(1)
2,两数平方和
参考SquaresSumTest 方法
3,归并两个有序数组
参考MergeArrayTest 方法
思路是原有思维方式是从头处理元素，换思路从尾部处理，利用角标处理
4,判断链表是否存在环
参考LinkListCycleTest方法
思路通过链表判断指向一个元素是否当前元素相等 如果相等说明有环
7，最长子序列
参考LongestWordTest
思路获取子序列中字符匹配最多的字符串  删除 的意思也有可能是索引获取 指向下一个


排序
1，题目描述：找到倒数第 k 个的元素
思路：1，数组排序 2，取元素通过lenght-k来获取
参考Solution
桶排序
2. 出现频率最多的 k 个元素
思路：通过map进行分组，然后key为频率 value为值
未解决
3，按照字符出现次数对字符串排序  tree-->eetr
涉及字符串频率问题，1，转字符数组 2，map 搞定频率次数 2，循环处理找出对应的值
字符串可以转换字符数组  然后
参考FrequencySort
4,按颜色进行排序
荷兰国旗包含三种颜色：红、白、蓝
解决方案：算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。
编程思路：确定最小元素，最大元素替换过程，判断等于最小目标值应该放在的位置，大于目标值应该放在的位置
参考SortColors

贪心思想
1. 分配饼干
在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解
参考FindContentChildren 类
2,不重叠的区间个数
找出判断条件，需要怎样做才能达到条件，先排序；再计算末尾熟和前面数比较
需要再看二维数组相关，以及比较相关方法
参考EraseOverlapInterval 类
3,投飞镖刺破气球
计算不重叠的区间个数
解题思路
1，排序
2，计算末尾不交集个数
参考FindMinArrowShots类
4. 根据身高和序号重组队列（整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列）
1，排序从高到低
2，根据index存放位置，使用ArrayList 里面可以根据index来存放值
参考ReconstructQueue
5.买卖股票最大的收益
题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益
解题思路
只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益
参考MaxProfit
6,买卖股票的最大收益 II
题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易
对于 [a, b, c, d]，如果有 a <= b <= c <= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] > 0，那么就把 prices[i] - prices[i-1] 添加到收益中
参考MaxProfit  maxProfit3方法
8判断是否为子序列 leetCode 392 参考Subsequence
题目描述：Given a string s and a string t, check if s is subsequence of t.  (ie, "ace" is a subsequence of "abcde" while "aec" is not)
解决思路：找出判断依据1，通过比对的方式 2判断依据s是否在s范围内比对完成，true的条件是s的最后一个字符也能匹配
遇到问题点1，判断异常的条件 s 和t 互为空时,其中一个为空时是否返回true 都是subsequence 2，字符串判断相等用equals方法 即使判断""
s为空时，肯定是  s、t都为空时都是 s不为空t为空时不是
9. 修改一个数成为非递减数组
分隔字符串使同种字符出现在一起 S = "ababcbacadefegdehijhklij" 输出Output: [9,7,8] The partition is "ababcbaca", "defegde", "hijhklij"
参考PartitionLabels
思路：
1，设置起始位置和结束位置 总条件是在字符串长度范围内，小范围是遍历起始位置和技术位置有没有大于这个范围的如果有替换继续查找，没有就加入 i++ 起始位置和结束位置都重新变更
注意要判断是不是最后一个元素 防止异常

二分查找
1，开平方
    //分析 求平方 实际上是找是否等于平方数  如果等于反回 如果不等于判断 算的中间数 和平方值比较
    //中间数大于平方值  起始范围mid+1到h  小于于l到mid-1
    //算中间值是动态变化的 l+(h-l)/2
    参考类SqrtTest
2，大于给定元素的最小元素
//关于查找的题目都要考虑二分查找，记住查找规则
参考NextGreatestLetter

